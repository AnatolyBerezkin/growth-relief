<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Growth Relief Generator</title>
    <style>
        /* Global reset and container styling */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* Main widget container - this is what Jimdo sees */
        #widget-container {
            width: 100%;
            height: 100vh;
            min-height: 600px;
            position: relative;
            background: #f0f5ff;
        }
        
        /* Three.js canvas covers entire container */
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: block;
        }
        
        /* UI Panel - draggable and resizable overlay */
        #uiPanel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 420px;
            max-height: calc(100vh - 40px);
            background: linear-gradient(to bottom, #c7dbff, #dce8ff);
            border: 1px solid #9fb4d6;
            border-radius: 8px;
            box-shadow: 4px 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            overflow-y: auto;
            padding: 18px;
            box-sizing: border-box;
            font-family: 'Segoe UI', sans-serif;
            color: #1a1f27;
            resize: both;
            overflow: auto;
            min-width: 300px;
            min-height: 400px;
        }
        
        /* Custom resizer handle */
        #uiPanel::-webkit-resizer {
            background-color: #4a90e2;
            border-radius: 2px;
        }
        
        /* Panel header with drag handle */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #9fb4d6;
        }
        
        /* Drag handle styling */
        .drag-handle {
            cursor: move;
            padding: 4px 8px;
            background: #4a90e2;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            user-select: none;
        }
        
        /* Close/minimize button */
        .close-btn {
            cursor: pointer;
            padding: 4px 8px;
            background: #ff4444;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }
        
        /* UI canvas elements styling */
        .ui-canvas {
            background: #000;
            border-radius: 6px;
            margin-top: 10px;
            border: 1px solid #9fb4d6;
            display: block;
        }
        
        /* Scrollbar styling for UI panel */
        #uiPanel::-webkit-scrollbar {
            width: 8px;
        }
        
        #uiPanel::-webkit-scrollbar-track {
            background: #dce8ff;
            border-radius: 4px;
        }
        
        #uiPanel::-webkit-scrollbar-thumb {
            background: #9fb4d6;
            border-radius: 4px;
        }
        
        /* Input and control styling */
        .control-input {
            width: 100%;
            box-sizing: border-box;
            margin-left: 6px;
            margin-bottom: 6px;
            font-size: 13px;
            background: #fff;
            border: 1px solid #9fb4d6;
            border-radius: 6px;
            padding: 6px 8px;
            color: #1a1f27;
        }
        
        .control-button {
            padding: 6px 16px;
            font-size: 14px;
            font-weight: 600;
            background: #4a90e2;
            border-radius: 6px;
            border: 1px solid #3a78c2;
            color: #fff;
            cursor: pointer;
        }
        
        .section-header {
            margin: 14px 0 8px;
            font-size: 15px;
            font-weight: 600;
            color: #003366;
            border-bottom: 1px solid #9fb4d6;
            padding-bottom: 4px;
        }
    </style>
</head>
<body>
    <!-- Single container widget for Jimdo -->
    <div id="widget-container">
        <!-- Three.js canvas - will be initialized by JavaScript -->
        <canvas id="threeCanvas"></canvas>
        
        <!-- UI Panel - draggable overlay with controls -->
        <div id="uiPanel">
            <div class="panel-header">
                <div class="drag-handle" id="dragHandle">☰ Drag</div>
                <div class="close-btn" id="togglePanelBtn" title="Minimize">✕</div>
            </div>
            
            <!-- UI Content Area -->
            <div id="uiContent">
                <!-- ===== GROWTH CONTROLS ===== -->
                <div class="section-header">Growth</div>
                
                <table style="width:100%; border-collapse:collapse; margin-bottom:15px;">
                    <tr>
                        <td style="padding:4px 2px; vertical-align:middle;">Attractors:</td>
                        <td style="padding:4px 2px; vertical-align:middle;">
                            <input id="points" type="number" value="5000" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Kill distance:</td>
                        <td style="padding:4px 2px;">
                            <input id="killDist" type="number" value="5" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Influence distance:</td>
                        <td style="padding:4px 2px;">
                            <input id="influenceDist" type="number" value="10" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Branch length:</td>
                        <td style="padding:4px 2px;">
                            <input id="branchLen" type="number" value="3" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Canvas width:</td>
                        <td style="padding:4px 2px;">
                            <input id="canvasW" type="number" value="300" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Canvas height:</td>
                        <td style="padding:4px 2px;">
                            <input id="canvasH" type="number" value="200" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Attractor mode:</td>
                        <td style="padding:4px 2px;">
                            <select id="attrMode" class="control-input">
                                <option value="uniform">Uniform</option>
                                <option value="fromfile">From file</option>
                                <option value="hexmesh">Hexagonal mesh</option>
                                <option value="rectmesh">Rectangular mesh</option>
                            </select>
                            <input type="file" id="attractorImageInput" accept="image/*" style="display:none;">
                            <button id="loadAttractorImageBtn" class="control-button" style="display:none; margin-top:5px;">Load attractor image</button>
                        </td>
                    </tr>
                    
                    <!-- Grid controls (hidden by default) -->
                    <tr id="gridPeriodLabel" style="display:none;">
                        <td style="padding:4px 2px;">Grid cells:</td>
                        <td style="padding:4px 2px;">
                            <input id="gridCellsX" type="number" value="35" min="1" style="width:48%;" class="control-input">
                            <input id="gridCellsY" type="number" value="35" min="1" style="width:48%;" class="control-input">
                        </td>
                    </tr>
                    
                    <tr id="gridProbLabel" style="display:none;">
                        <td style="padding:4px 2px;">Grid probability:</td>
                        <td style="padding:4px 2px;">
                            <input id="gridProb" type="range" min="0" max="1" step="0.01" value="1" style="width:120px; height:4px; border-radius:4px; background:#c0cce0; outline:none;">
                        </td>
                    </tr>
                    
                    <tr id="gridJitterLabel" style="display:none;">
                        <td style="padding:4px 2px;">Grid jitter:</td>
                        <td style="padding:4px 2px;">
                            <input id="gridJitter" type="range" min="0" max="1" step="0.01" value="0.2" style="width:120px; height:4px; border-radius:4px; background:#c0cce0; outline:none;">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Roots:</td>
                        <td style="padding:4px 2px;">
                            <input id="roots" type="number" value="5" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Root mode:</td>
                        <td style="padding:4px 2px;">
                            <select id="rootMode" class="control-input">
                                <option value="random0">Random</option>
                                <option value="random1">Random (bottom)</option>
                                <option value="line">Line (bottom)</option>
                                <option value="circle">Circle</option>
                            </select>
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px; text-align:center;">
                            <button id="start" class="control-button">Start growth</button>
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px;">
                            <canvas id="canvas" width="300" height="200" class="ui-canvas"></canvas>
                        </td>
                    </tr>
                </table>
                
                <!-- ===== DEPTH PROFILE CONTROLS ===== -->
                <div class="section-header">Depth profile</div>
                
                <table style="width:100%; border-collapse:collapse; margin-bottom:15px;">
                    <tr>
                        <td colspan="2" style="padding:4px 2px;">
                            <canvas id="bezierCanvas" width="300" height="150" class="ui-canvas"></canvas>
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Max thickness (px):</td>
                        <td style="padding:4px 2px;">
                            <input id="depthThickness" type="number" value="25" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Bilateral radius:</td>
                        <td style="padding:4px 2px;">
                            <input id="bilateralRadius" type="number" value="2" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px; text-align:center;">
                            <button id="genDepth" class="control-button">Generate Depth Map</button>
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px; text-align:center;">
                            <button id="export16" class="control-button">Export PNG</button>
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px;">
                            <canvas id="depthCanvas" width="300" height="200" class="ui-canvas"></canvas>
                        </td>
                    </tr>
                </table>
                
                <!-- ===== 3D PANEL CONTROLS ===== -->
                <div class="section-header">Panel & STL</div>
                
                <table style="width:100%; border-collapse:collapse;">
                    <tr>
                        <td style="padding:4px 2px;">Panel thickness (mm):</td>
                        <td style="padding:4px 2px;">
                            <input id="panelThickness" type="number" value="50" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Relief height (mm):</td>
                        <td style="padding:4px 2px;">
                            <input id="reliefHeight" type="number" value="20" class="control-input">
                        </td>
                    </tr>
                    
                    <tr>
                        <td style="padding:4px 2px;">Invert:</td>
                        <td style="padding:4px 2px;">
                            <label style="display:flex; align-items:center;">
                                <input type="checkbox" id="invertToggle" style="margin-right:6px;">
                                <span>Invert</span>
                            </label>
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px; text-align:center;">
                            <button id="buildMesh" class="control-button">Build 3D Mesh</button>
                        </td>
                    </tr>
                    
                    <tr>
                        <td colspan="2" style="padding:4px 2px; text-align:center;">
                            <button id="exportSTL" class="control-button">Export STL</button>
                        </td>
                    </tr>
                </table>
            </div>
        </div>
    </div>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    
    <!-- Main application script -->
    <script>
    // ============================================================================
    // UI PANEL DRAGGING AND RESIZING
    // ============================================================================
    
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let uiPanelVisible = true;
    
    // Initialize UI panel dragging
    function initUIPanelDrag() {
        const panel = document.getElementById('uiPanel');
        const dragHandle = document.getElementById('dragHandle');
        
        dragHandle.addEventListener('mousedown', startDrag);
        document.addEventListener('mousemove', doDrag);
        document.addEventListener('mouseup', stopDrag);
        
        function startDrag(e) {
            isDragging = true;
            const rect = panel.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            panel.style.cursor = 'grabbing';
            e.preventDefault();
        }
        
        function doDrag(e) {
            if (!isDragging) return;
            
            // Calculate new position
            const container = document.getElementById('widget-container');
            const containerRect = container.getBoundingClientRect();
            const panelRect = panel.getBoundingClientRect();
            
            let newX = e.clientX - dragOffsetX - containerRect.left;
            let newY = e.clientY - dragOffsetY - containerRect.top;
            
            // Constrain within container bounds
            newX = Math.max(0, Math.min(newX, containerRect.width - panelRect.width));
            newY = Math.max(0, Math.min(newY, containerRect.height - panelRect.height));
            
            panel.style.left = newX + 'px';
            panel.style.top = newY + 'px';
        }
        
        function stopDrag() {
            isDragging = false;
            panel.style.cursor = '';
        }
    }
    
    // Toggle UI panel visibility
    function toggleUIPanel() {
        const panel = document.getElementById('uiPanel');
        const toggleBtn = document.getElementById('togglePanelBtn');
        
        uiPanelVisible = !uiPanelVisible;
        
        if (uiPanelVisible) {
            panel.style.display = 'block';
            toggleBtn.textContent = '✕';
            toggleBtn.title = 'Minimize';
        } else {
            panel.style.display = 'none';
            toggleBtn.textContent = '☰';
            toggleBtn.title = 'Maximize';
        }
    }
    
    // ============================================================================
    // THREE.JS SCENE INITIALIZATION
    // ============================================================================
    
    let scene, camera, renderer, reliefMesh = null;
    let canvas, ctx; // 2D canvas for growth visualization
    
    // Initialize Three.js scene
    function initThree() {
        const container = document.getElementById('widget-container');
        const threeCanvas = document.getElementById('threeCanvas');
        
        // Get container dimensions
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f5ff);
        
        // Create camera (perspective, Z-up)
        camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
        camera.position.set(0, -500, 500);
        camera.up.set(0, 0, 1);
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({
            canvas: threeCanvas,
            antialias: true,
            alpha: true
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // Initialize camera controls
        initCameraControls();
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(300, -300, 500);
        scene.add(directionalLight);
        
        // Add a simple grid helper for reference
        const gridHelper = new THREE.GridHelper(500, 50, 0x888888, 0xcccccc);
        gridHelper.position.z = -1;
        scene.add(gridHelper);
        
        // Start animation loop
        animate();
        
        // Handle window resize
        window.addEventListener('resize', onWindowResize);
    }
    
    // Custom camera controls
    function initCameraControls() {
        let radius = 800;
        let theta = 90;
        let phi = 90;
        let target = new THREE.Vector3(0, 0, 0);
        
        let isDraggingCamera = false;
        let isRightButton = false;
        let prevX = 0, prevY = 0;
        
        const threeCanvas = document.getElementById('threeCanvas');
        
        function updateCamera() {
            const rPhi = THREE.MathUtils.degToRad(phi);
            const rTheta = THREE.MathUtils.degToRad(theta);
            
            camera.position.set(
                radius * Math.cos(rPhi) * Math.cos(rTheta) + target.x,
                radius * Math.cos(rPhi) * Math.sin(rTheta) + target.y,
                radius * Math.sin(rPhi) + target.z
            );
            
            camera.lookAt(target);
        }
        
        // Mouse events for camera control
        threeCanvas.addEventListener('mousedown', (e) => {
            // Only handle camera if not dragging UI panel
            if (isDragging) return;
            
            isDraggingCamera = true;
            isRightButton = (e.button === 2);
            prevX = e.clientX;
            prevY = e.clientY;
            threeCanvas.style.cursor = 'grabbing';
        });
        
        window.addEventListener('mouseup', () => {
            isDraggingCamera = false;
            threeCanvas.style.cursor = '';
        });
        
        threeCanvas.addEventListener('mousemove', (e) => {
            if (!isDraggingCamera) return;
            
            const dx = e.clientX - prevX;
            const dy = e.clientY - prevY;
            prevX = e.clientX;
            prevY = e.clientY;
            
            if (!isRightButton) {
                // Rotate camera
                theta -= dx * 0.5;
                theta = ((theta % 360) + 360) % 360;
                
                phi += dy * 0.5;
                phi = Math.max(-89.9, Math.min(89.9, phi));
            } else {
                // Pan camera
                const panSpeed = 1;
                const forward = new THREE.Vector3();
                const right = new THREE.Vector3();
                const up = new THREE.Vector3();
                const pan = new THREE.Vector3();
                
                camera.getWorldDirection(forward);
                right.crossVectors(camera.up, forward).normalize();
                up.copy(camera.up).normalize();
                
                right.multiplyScalar(dx * panSpeed);
                up.multiplyScalar(dy * panSpeed);
                
                pan.addVectors(right, up);
                target.add(pan);
            }
            
            updateCamera();
        });
        
        // Zoom with mouse wheel
        threeCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            radius += e.deltaY * 0.5;
            radius = Math.max(50, Math.min(5000, radius));
            
            updateCamera();
        }, { passive: false });
        
        // Prevent context menu
        threeCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Initial camera update
        updateCamera();
    }
    
    // Handle window resize
    function onWindowResize() {
        const container = document.getElementById('widget-container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    }
    
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    }
    
    // ============================================================================
    // BRANCH GROWTH SYSTEM (Space Colonization Algorithm)
    // ============================================================================
    
    // Branch class representing a segment in the growth system
    class Branch {
        constructor(x, y, parent = null, len = 3) {
            this.x = x;
            this.y = y;
            this.parent = parent;
            this.growDir = { x: 0, y: 0 }; // Accumulated growth direction
            this.count = 0;                // Number of attractors influencing this branch
            this.len = len;                // Branch segment length
        }
        
        // Create next branch segment in the accumulated direction
        next() {
            return new Branch(
                this.x + this.growDir.x * this.len,
                this.y + this.growDir.y * this.len,
                this,
                this.len
            );
        }
    }
    
    // Global variables for growth system
    let attractors = [];
    let branches = [];
    let params = {};
    
    // Color constants (0xRRGGBB)
    const COLOR_BG = 0x000000;
    const COLOR_BRANCH = 0xffffff;
    const COLOR_ATTR = 0x00ff00;
    
    // Initialize attractors and root branches
    function initGrowth() {
        // Get parameters from UI
        params.points = +document.getElementById("points").value;
        params.killDist = +document.getElementById("killDist").value;
        params.influenceDist = +document.getElementById("influenceDist").value;
        params.branchLen = +document.getElementById("branchLen").value;
        params.canvasW = +document.getElementById("canvasW").value;
        params.canvasH = +document.getElementById("canvasH").value;
        params.bgColor = COLOR_BG;
        params.branchColor = COLOR_BRANCH;
        params.attrColor = COLOR_ATTR;
        params.attrMode = document.getElementById("attrMode").value;
        params.roots = +document.getElementById("roots").value;
        params.rootMode = document.getElementById("rootMode").value;
        
        // Setup 2D canvas for growth visualization
        canvas = document.getElementById("canvas");
        canvas.width = params.canvasW;
        canvas.height = params.canvasH;
        ctx = canvas.getContext("2d");
        
        // Generate attractors based on selected mode
        if (params.attrMode === "uniform") {
            attractors = [];
            for (let i = 0; i < params.points; i++) {
                attractors.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height
                });
            }
        } else if (params.attrMode === "rectmesh") {
            generateRectMesh();
        } else if (params.attrMode === "hexmesh") {
            generateHexMesh();
        }
        // Note: "fromfile" mode would require additional handling
        
        // Generate root branches based on selected mode
        branches = [];
        if (params.rootMode === "line") {
            // Evenly spaced along the bottom
            for (let i = 0; i < params.roots; i++) {
                branches.push(new Branch(
                    (i + 0.5) * (canvas.width / params.roots),
                    canvas.height - 20,
                    null,
                    params.branchLen
                ));
            }
        } else if (params.rootMode === "random1") {
            // Random positions along the bottom
            for (let i = 0; i < params.roots; i++) {
                branches.push(new Branch(
                    Math.random() * canvas.width,
                    canvas.height - 0,
                    null,
                    params.branchLen
                ));
            }
        } else if (params.rootMode === "circle") {
            // Roots arranged in a circle
            let cx = canvas.width / 2;
            let cy = canvas.height / 2;
            let r = Math.min(canvas.width, canvas.height) * 0.3;
            for (let i = 0; i < params.roots; i++) {
                let a = (i / params.roots) * 2 * Math.PI;
                branches.push(new Branch(
                    cx + r * Math.cos(a),
                    cy + r * Math.sin(a),
                    null,
                    params.branchLen
                ));
            }
        } else if (params.rootMode === "random0") {
            // Select roots from attractors
            for (let i = 0; i < params.roots; i++) {
                let a = attractors[Math.floor(Math.random() * attractors.length)];
                branches.push(new Branch(
                    a.x,
                    a.y,
                    null,
                    params.branchLen
                ));
            }
        }
        
        // Start growth animation
        drawGrowth();
        loopGrowth();
    }
    
    // Single growth iteration
    function stepGrowth() {
        // Reset growth directions
        for (let b of branches) {
            b.growDir.x = 0;
            b.growDir.y = 0;
            b.count = 0;
        }
        
        // Process attractors
        for (let i = attractors.length - 1; i >= 0; i--) {
            let a = attractors[i];
            let closest = null;
            let dmin = Infinity;
            
            // Find closest branch within influence distance
            for (let b of branches) {
                let d = dist(a.x, a.y, b.x, b.y, canvas.width, canvas.height);
                
                // Remove attractor if too close
                if (d < params.killDist) {
                    attractors.splice(i, 1);
                    closest = null;
                    break;
                }
                
                if (d < params.influenceDist && d < dmin) {
                    closest = b;
                    dmin = d;
                }
            }
            
            // Accumulate growth direction
            if (closest) {
                let dx = a.x - closest.x;
                let dy = a.y - closest.y;
                let mag = Math.sqrt(dx * dx + dy * dy);
                
                closest.growDir.x += dx / mag;
                closest.growDir.y += dy / mag;
                closest.count++;
            }
        }
        
        // Create new branches
        let newBranches = [];
        for (let b of branches) {
            if (b.count > 0) {
                b.growDir.x /= b.count;
                b.growDir.y /= b.count;
                let nb = b.next();
                newBranches.push(nb);
            }
        }
        
        // Stop if no new branches were created
        if (newBranches.length === 0) {
            return false; // Growth finished
        }
        
        branches.push(...newBranches);
        return true; // Growth continues
    }
    
    // Draw branches and attractors
    function drawGrowth() {
        // Clear canvas
        ctx.fillStyle = "#" + params.bgColor.toString(16).padStart(6, "0");
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw attractors
        let img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        let data = img.data;
        
        let color = params.attrColor;
        let r = (color >> 16) & 255;
        let g = (color >> 8) & 255;
        let b = color & 255;
        
        for (let a of attractors) {
            let x = a.x | 0;
            let y = a.y | 0;
            
            if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) continue;
            
            let i = (y * canvas.width + x) * 4;
            data[i] = r;
            data[i + 1] = g;
            data[i + 2] = b;
            data[i + 3] = 255;
        }
        
        ctx.putImageData(img, 0, 0);
        
        // Draw branches
        ctx.strokeStyle = "#" + params.branchColor.toString(16).padStart(6, "0");
        ctx.beginPath();
        for (let b of branches) {
            if (!b.parent) continue;
            
            let x1 = b.x, y1 = b.y;
            let x2 = b.parent.x, y2 = b.parent.y;
            
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
        }
        ctx.stroke();
    }
    
    // Growth animation loop
    function loopGrowth() {
        let alive = stepGrowth();
        drawGrowth();
        
        if (alive) {
            requestAnimationFrame(loopGrowth);
        } else {
            console.log("Growth finished.");
        }
    }
    
    // Helper functions for growth system
    function dist(ax, ay, bx, by, w, h) {
        let dx = ax - bx;
        if (dx > w / 2) dx -= w;
        if (dx < -w / 2) dx += w;
        
        let dy = ay - by;
        if (dy > h / 2) dy -= h;
        if (dy < -h / 2) dy += h;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    function generateHexMesh() {
        // Implementation from original code
        let nX = +document.getElementById("gridCellsX").value;
        let nY = +document.getElementById("gridCellsY").value;
        let W = canvas.width;
        let H = canvas.height;
        
        let periodX = W / nX;
        let periodY = H / nY;
        let prob = +document.getElementById("gridProb").value;
        let jitter = +document.getElementById("gridJitter").value;
        
        let jitterAmpX = jitter * (periodX * 0.5);
        let jitterAmpY = jitter * (periodY * 0.5);
        
        attractors = [];
        
        for (let iy = 0; iy < nY; iy++) {
            for (let ix = 0; ix < nX; ix++) {
                if (Math.random() > prob) continue;
                
                let offsetX = (iy % 2 === 1) ? periodX * 0.5 : 0;
                let cx = ix * periodX + offsetX + periodX * 0.5;
                let cy = iy * periodY + periodY * 0.5;
                
                let jitterX = (Math.random() - 0.5) * 2 * jitterAmpX;
                let jitterY = (Math.random() - 0.5) * 2 * jitterAmpY;
                
                let x = Math.round(cx + jitterX);
                let y = Math.round(cy + jitterY);
                
                attractors.push({ x, y });
            }
        }
    }
    
    function generateRectMesh() {
        // Implementation from original code
        let nX = +document.getElementById("gridCellsX").value;
        let nY = +document.getElementById("gridCellsY").value;
        let W = canvas.width;
        let H = canvas.height;
        
        let periodX = W / nX;
        let periodY = H / nY;
        let prob = +document.getElementById("gridProb").value;
        let jitter = +document.getElementById("gridJitter").value;
        
        let jitterAmpX = jitter * (periodX * 0.5);
        let jitterAmpY = jitter * (periodY * 0.5);
        
        attractors = [];
        
        for (let iy = 0; iy < nY; iy++) {
            for (let ix = 0; ix < nX; ix++) {
                if (Math.random() > prob) continue;
                
                let cx = ix * periodX + periodX * 0.5;
                let cy = iy * periodY + periodY * 0.5;
                
                let jitterX = (Math.random() - 0.5) * 2 * jitterAmpX;
                let jitterY = (Math.random() - 0.5) * 2 * jitterAmpY;
                
                let x = Math.round(cx + jitterX);
                let y = Math.round(cy + jitterY);
                
                attractors.push({ x, y });
            }
        }
    }
    
    // ============================================================================
    // APPLICATION INITIALIZATION
    // ============================================================================
    
    // Initialize everything when page loads
    window.addEventListener('load', () => {
        // Initialize Three.js scene
        initThree();
        
        // Initialize UI panel dragging
        initUIPanelDrag();
        
        // Initialize event listeners for controls
        initEventListeners();
        
        // Initialize canvas backgrounds
        initCanvasBackgrounds();
        
        // Initialize Bezier editor
        initBezierEditor();
        
        console.log("Growth Relief Generator initialized");
    });
    
    // Initialize event listeners for all controls
    function initEventListeners() {
        // Growth controls
        document.getElementById("start").addEventListener("click", initGrowth);
        
        // Attractor mode change
        document.getElementById("attrMode").addEventListener("change", function() {
            const mode = this.value;
            const btn = document.getElementById("loadAttractorImageBtn");
            const gridUI = document.getElementById("gridPeriodLabel");
            const probUI = document.getElementById("gridProbLabel");
            const jitterUI = document.getElementById("gridJitterLabel");
            
            if (mode === "fromfile") {
                btn.style.display = "block";
            } else {
                btn.style.display = "none";
            }
            
            if (mode === "rectmesh" || mode === "hexmesh") {
                gridUI.style.display = "block";
                probUI.style.display = "block";
                jitterUI.style.display = "block";
            } else {
                gridUI.style.display = "none";
                probUI.style.display = "none";
                jitterUI.style.display = "none";
            }
        });
        
        // File upload for attractor image
        document.getElementById("loadAttractorImageBtn").addEventListener("click", () => {
            document.getElementById("attractorImageInput").click();
        });
        
        // Depth profile controls
        document.getElementById("depthThickness").addEventListener("input", function() {
            const newValue = parseFloat(this.value);
            setMaxThickness(newValue);
        });
        
        document.getElementById("genDepth").addEventListener("click", generateDepthMapSDF);
        document.getElementById("export16").addEventListener("click", exportHeightmap16);
        
        // 3D mesh controls
        document.getElementById("buildMesh").addEventListener("click", buildHeightFieldMesh);
        document.getElementById("exportSTL").addEventListener("click", exportSTL);
        
        // Panel toggle button
        document.getElementById("togglePanelBtn").addEventListener("click", toggleUIPanel);
    }
    
    // Initialize canvas backgrounds
    function initCanvasBackgrounds() {
        const canvases = [
            { id: "canvas", color: "#000" },
            { id: "bezierCanvas", color: "#333" },
            { id: "depthCanvas", color: "#000" }
        ];
        
        canvases.forEach(canvasInfo => {
            const canvas = document.getElementById(canvasInfo.id);
            if (canvas) {
                const ctx = canvas.getContext("2d");
                ctx.fillStyle = canvasInfo.color;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        });
    }
    
    // Note: The following functions would need to be implemented based on your original code:
    // - Bezier editor functions (initBezierEditor, setMaxThickness, etc.)
    // - Depth map generation (generateDepthMapSDF)
    // - 3D mesh building (buildHeightFieldMesh)
    // - Export functions (exportHeightmap16, exportSTL)
    // - Distance field utilities and bilateral blur
    
    // These would be adapted from your original code but modified to work with the new architecture
    
    // ============================================================================
    // STUB FUNCTIONS - TO BE IMPLEMENTED FROM ORIGINAL CODE
    // ============================================================================
    
    function initBezierEditor() {
        console.log("Bezier editor initialized (stub)");
        // Implementation from original code would go here
    }
    
    function setMaxThickness(value) {
        console.log("Set max thickness to:", value);
        // Implementation from original code would go here
    }
    
    function generateDepthMapSDF() {
        console.log("Generate depth map (stub)");
        alert("Depth map generation would be implemented here");
        // Implementation from original code would go here
    }
    
    function buildHeightFieldMesh() {
        console.log("Build 3D mesh (stub)");
        alert("3D mesh building would be implemented here");
        // Implementation from original code would go here
    }
    
    function exportHeightmap16() {
        console.log("Export PNG (stub)");
        alert("PNG export would be implemented here");
        // Implementation from original code would go here
    }
    
    function exportSTL() {
        console.log("Export STL (stub)");
        alert("STL export would be implemented here");
        // Implementation from original code would go here
    }
    
    </script>
</body>
</html>